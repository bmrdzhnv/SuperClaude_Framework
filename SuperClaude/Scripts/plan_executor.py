#!/usr/bin/env python3
"""
SuperClaude Plan Executor
Executes plans generated by /sc:plan command with validation and progress tracking.
"""

import json
import sys
import os
import time
import subprocess
import argparse
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum


class StepStatus(Enum):
    """Execution status for plan steps."""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"
    ROLLED_BACK = "rolled_back"


@dataclass
class ExecutionResult:
    """Result of a step execution."""
    step_id: int
    status: StepStatus
    duration: float
    output: str
    error: Optional[str] = None


class PlanExecutor:
    """Executes SuperClaude plans with validation and tracking."""

    def __init__(self, plan_path: Path, dry_run: bool = False, step_mode: bool = False):
        self.plan_path = plan_path
        self.dry_run = dry_run
        self.step_mode = step_mode
        self.plan: Dict[str, Any] = {}
        self.results: List[ExecutionResult] = []
        self.start_time = time.time()
        self.plans_dir = Path.home() / ".claude" / "plans"
        self.logs_dir = Path.home() / ".claude" / "logs"
        self.logs_dir.mkdir(parents=True, exist_ok=True)

    def load_plan(self) -> bool:
        """Load and validate plan from JSON file."""
        try:
            # If no specific path given, load latest plan
            if not self.plan_path or self.plan_path == Path("latest"):
                plans = list(self.plans_dir.glob("*.json"))
                if not plans:
                    print("‚ùå No plans found in ~/.claude/plans/")
                    return False
                self.plan_path = max(plans, key=lambda p: p.stat().st_mtime)

            with open(self.plan_path, 'r') as f:
                self.plan = json.load(f)

            print(f"üìã Loaded plan: {self.plan.get('goal', 'Unknown')}")
            print(f"   ID: {self.plan.get('plan_id', 'none')}")
            print(f"   Steps: {len(self.plan.get('steps', []))}")
            print(f"   Complexity: {self.plan.get('complexity', 'unknown')}")
            return True

        except FileNotFoundError:
            print(f"‚ùå Plan file not found: {self.plan_path}")
            return False
        except json.JSONDecodeError as e:
            print(f"‚ùå Invalid JSON in plan file: {e}")
            return False

    def validate_plan(self) -> bool:
        """Validate plan structure and dependencies."""
        if not self.plan.get('steps'):
            print("‚ùå No steps defined in plan")
            return False

        # Check required fields
        for i, step in enumerate(self.plan['steps'], 1):
            required = ['command']
            for field in required:
                if field not in step:
                    print(f"‚ùå Step {i} missing required field: {field}")
                    return False

        # Validate dependencies
        step_ids = {step.get('id', i) for i, step in enumerate(self.plan['steps'], 1)}
        for step in self.plan['steps']:
            deps = step.get('depends_on', [])
            if deps and not all(d in step_ids for d in deps):
                print(f"‚ùå Invalid dependency in step {step.get('id')}: {deps}")
                return False

        print("‚úÖ Plan validation passed")
        return True

    def execute_command(self, command: str, args: str = "") -> tuple[bool, str]:
        """Execute a SuperClaude command."""
        full_command = f"{command} {args}".strip()

        if self.dry_run:
            print(f"   [DRY RUN] Would execute: {full_command}")
            return True, "Dry run - no execution"

        # In real implementation, this would call Claude Code
        # For now, simulate with subprocess call
        try:
            # Construct the actual command to execute
            if command.startswith('/sc:'):
                # SuperClaude command - would need special handling
                print(f"   ‚Üí Executing: {full_command}")
                time.sleep(1)  # Simulate execution
                return True, f"Simulated execution of {full_command}"
            else:
                # Regular shell command
                result = subprocess.run(
                    full_command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                return result.returncode == 0, result.stdout or result.stderr
        except subprocess.TimeoutExpired:
            return False, "Command timed out after 5 minutes"
        except Exception as e:
            return False, str(e)

    def execute_step(self, step: Dict[str, Any], step_num: int, total: int) -> ExecutionResult:
        """Execute a single plan step."""
        step_id = step.get('id', step_num)
        command = step['command']
        args = step.get('args', '')

        print(f"\n‚ñ∂Ô∏è  Step {step_num}/{total}: {step.get('description', command)}")
        print(f"   Command: {command} {args}")

        if step.get('agents'):
            print(f"   Agents: {step['agents']}")

        # Check if step should be executed
        if self.step_mode:
            response = input("   Execute this step? [Y/n/s(kip)]: ").lower()
            if response == 'n':
                print("   ‚èπÔ∏è  Execution aborted by user")
                sys.exit(1)
            elif response == 's':
                return ExecutionResult(
                    step_id=step_id,
                    status=StepStatus.SKIPPED,
                    duration=0,
                    output="Skipped by user"
                )

        # Execute the command
        start = time.time()
        success, output = self.execute_command(command, args)
        duration = time.time() - start

        # Validate result if criteria specified
        if success and step.get('validation'):
            print(f"   üîç Validating: {step['validation']}")
            # In real implementation, would run validation
            success = True  # Simulate validation pass

        # Create result
        result = ExecutionResult(
            step_id=step_id,
            status=StepStatus.SUCCESS if success else StepStatus.FAILED,
            duration=duration,
            output=output[:500] if output else "",  # Truncate long output
            error=None if success else output
        )

        # Display result
        if success:
            print(f"   ‚úÖ Complete ({duration:.1f}s)")
        else:
            print(f"   ‚ùå Failed: {output[:200]}")

        return result

    def handle_failure(self, step: Dict[str, Any], result: ExecutionResult) -> bool:
        """Handle step failure with recovery options."""
        print("\n‚ö†Ô∏è  Step failed!")
        print("   Options:")
        print("   [r] Retry step")
        print("   [s] Skip and continue")
        print("   [b] Rollback all changes")
        print("   [a] Abort execution")

        choice = input("   Choose [r/s/b/a]: ").lower()

        if choice == 'r':
            return True  # Retry
        elif choice == 's':
            result.status = StepStatus.SKIPPED
            return False  # Don't retry
        elif choice == 'b':
            self.rollback()
            sys.exit(1)
        else:  # abort
            print("‚ùå Execution aborted")
            sys.exit(1)

    def rollback(self):
        """Execute rollback procedures."""
        print("\nüîÑ Executing rollback...")
        rollback_steps = self.plan.get('rollback', [])

        if not rollback_steps:
            print("   No rollback procedures defined")
            return

        for step in rollback_steps:
            print(f"   ‚Üí {step}")
            if not self.dry_run:
                # Execute rollback command
                subprocess.run(step, shell=True, capture_output=True)

        print("‚úÖ Rollback complete")

    def execute(self) -> bool:
        """Execute the complete plan."""
        if not self.load_plan():
            return False

        if not self.validate_plan():
            return False

        steps = self.plan['steps']
        total = len(steps)

        print(f"\nüöÄ Starting execution: {total} steps")
        if self.dry_run:
            print("   [DRY RUN MODE - No actual commands will be executed]")

        # Execute steps
        for i, step in enumerate(steps, 1):
            # Check dependencies
            deps = step.get('depends_on', [])
            if deps:
                failed_deps = [d for d in deps
                             if any(r.step_id == d and r.status == StepStatus.FAILED
                                   for r in self.results)]
                if failed_deps:
                    print(f"\n‚è≠Ô∏è  Skipping step {i}: Failed dependencies {failed_deps}")
                    self.results.append(ExecutionResult(
                        step_id=step.get('id', i),
                        status=StepStatus.SKIPPED,
                        duration=0,
                        output=f"Skipped due to failed dependencies: {failed_deps}"
                    ))
                    continue

            # Execute step
            result = self.execute_step(step, i, total)
            self.results.append(result)

            # Handle failure
            if result.status == StepStatus.FAILED:
                retry = self.handle_failure(step, result)
                if retry:
                    # Retry the step
                    result = self.execute_step(step, i, total)
                    self.results[-1] = result

        # Generate summary
        self.print_summary()

        # Save execution log
        self.save_log()

        # Return success if no critical failures
        failed = sum(1 for r in self.results if r.status == StepStatus.FAILED)
        return failed == 0

    def print_summary(self):
        """Print execution summary."""
        total_time = time.time() - self.start_time
        successful = sum(1 for r in self.results if r.status == StepStatus.SUCCESS)
        failed = sum(1 for r in self.results if r.status == StepStatus.FAILED)
        skipped = sum(1 for r in self.results if r.status == StepStatus.SKIPPED)

        print("\n" + "="*50)
        print("üìä Execution Summary")
        print("="*50)
        print(f"   Plan: {self.plan.get('goal', 'Unknown')}")
        print(f"   Total Steps: {len(self.results)}")
        print(f"   ‚úÖ Successful: {successful}")
        print(f"   ‚ùå Failed: {failed}")
        print(f"   ‚è≠Ô∏è  Skipped: {skipped}")
        print(f"   ‚è±Ô∏è  Total Time: {total_time:.1f}s")

        if failed == 0:
            print("\n‚úÖ Plan executed successfully!")
        else:
            print(f"\n‚ö†Ô∏è  Plan completed with {failed} failed steps")

    def save_log(self):
        """Save execution log to file."""
        log_file = self.logs_dir / f"execution_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        log_data = {
            'plan_id': self.plan.get('plan_id'),
            'goal': self.plan.get('goal'),
            'executed_at': datetime.now().isoformat(),
            'duration': time.time() - self.start_time,
            'dry_run': self.dry_run,
            'results': [
                {
                    'step_id': r.step_id,
                    'status': r.status.value,
                    'duration': r.duration,
                    'output': r.output,
                    'error': r.error
                }
                for r in self.results
            ]
        }

        with open(log_file, 'w') as f:
            json.dump(log_data, f, indent=2)

        print(f"\nüìù Execution log saved: {log_file}")


def main():
    """Main entry point for plan executor."""
    parser = argparse.ArgumentParser(description='Execute SuperClaude plans')
    parser.add_argument('plan', nargs='?', default='latest',
                      help='Path to plan JSON file or "latest"')
    parser.add_argument('--dry-run', action='store_true',
                      help='Simulate execution without running commands')
    parser.add_argument('--step', action='store_true',
                      help='Step-by-step execution with confirmation')
    parser.add_argument('--from', dest='from_step', type=int,
                      help='Start execution from specific step number')
    parser.add_argument('--rollback', action='store_true',
                      help='Execute rollback procedures')

    args = parser.parse_args()

    # Handle rollback
    if args.rollback:
        executor = PlanExecutor(Path(args.plan))
        if executor.load_plan():
            executor.rollback()
        return

    # Convert plan argument to Path
    if args.plan == 'latest':
        plan_path = Path('latest')
    elif args.plan.startswith('~'):
        plan_path = Path(os.path.expanduser(args.plan))
    else:
        plan_path = Path(args.plan)

    # Execute plan
    executor = PlanExecutor(
        plan_path=plan_path,
        dry_run=args.dry_run,
        step_mode=args.step
    )

    success = executor.execute()
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()